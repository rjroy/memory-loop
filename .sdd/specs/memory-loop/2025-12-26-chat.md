---
version: 1.0.0
status: Draft
created: 2025-12-26
last_updated: 2025-12-26
authored_by:
  - Claude Code
---

# Chat Feature Specification

**Reverse-Engineered**: true
**Source Module**: frontend/src/components/Discussion.tsx, backend/src/websocket-handler.ts, backend/src/session-manager.ts

## Executive Summary

The Chat Feature (Discussion mode) provides AI-powered conversations about vault content using Claude AI via the Claude Agent SDK. Users can ask questions, explore notes, and interact with their Obsidian vault through natural language conversations. The feature supports streaming responses for real-time feedback, tool usage visualization when Claude reads files or searches the vault, session persistence for resuming conversations, and draft preservation to prevent data loss.

This is the primary interactive feature of Memory Loop, enabling users to have contextual discussions about their knowledge base with Claude acting as an intelligent assistant with read access to vault contents.

## User Story

As a vault owner, I want to have AI-powered conversations about my notes and knowledge base, so that I can explore connections, get insights, and interact with my content through natural language without manually searching through files.

## Stakeholders

- **Primary**: Vault owners who want to interact with their notes through AI conversations
- **Secondary**: Frontend developers maintaining the React components, Backend developers managing WebSocket protocol and SDK integration

## Success Criteria

1. Users can send messages and receive streaming AI responses with visible typing indicators
2. Conversations persist across sessions and can be resumed without loss of context
3. Tool usage (file reads, searches) is displayed transparently to users during AI responses
4. Draft messages are preserved in localStorage to prevent accidental data loss
5. Sessions can be created, resumed, and reset (new conversation) without errors

## Functional Requirements

### Message Exchange

- **REQ-F-1**: System must accept text messages from users via textarea input
- **REQ-F-2**: System must stream AI responses chunk-by-chunk for real-time display
- **REQ-F-3**: System must display user and assistant messages in chronological order with timestamps
- **REQ-F-4**: System must support multi-line messages via Shift+Enter (Enter alone submits)
- **REQ-F-5**: System must disable input during response streaming to prevent race conditions
- **REQ-F-6**: System must render assistant messages with Markdown formatting (including GitHub Flavored Markdown)
- **REQ-F-7**: System must display streaming cursor (▊) on assistant messages being received

### Session Management

- **REQ-F-8**: System must create new SDK sessions lazily on first message
- **REQ-F-9**: System must persist session metadata to `~/.memory-loop/sessions/` as JSON files
- **REQ-F-10**: System must resume existing sessions when user reconnects or refreshes
- **REQ-F-11**: System must restore conversation history when resuming sessions
- **REQ-F-12**: System must allow users to start new sessions (clear context) via "New" button
- **REQ-F-13**: System must validate session IDs to prevent path traversal attacks
- **REQ-F-14**: System must automatically select vault from session metadata when resuming without prior vault selection
- **REQ-F-15**: System must send `new_session` message to backend when user clears session
- **REQ-F-16**: System must check for existing sessions via API `/api/sessions/{vaultId}` before creating new ones

### Tool Usage Display

- **REQ-F-17**: System must display tool invocations (Read, Grep, etc.) as expandable cards
- **REQ-F-18**: Tool cards must show tool name and loading spinner during execution
- **REQ-F-19**: Tool cards must display input parameters when expanded
- **REQ-F-20**: Tool cards must display output/result when expanded
- **REQ-F-21**: Tool cards must extract meaningful summaries (file names, patterns, commands) for collapsed state
- **REQ-F-22**: Tool cards must truncate long inputs/outputs to 5000 characters with ellipsis

### Draft Persistence

- **REQ-F-23**: System must save input text to localStorage (`memory-loop-discussion-draft`) on every change
- **REQ-F-24**: System must restore draft from localStorage on component mount
- **REQ-F-25**: System must clear localStorage draft after successful message submission
- **REQ-F-26**: Inspiration prefill must take precedence over localStorage draft

### Slash Command Detection

- **REQ-F-27**: System must detect messages starting with "/" as slash commands
- **REQ-F-28**: System must display "Slash command detected" hint when input starts with "/"
- **REQ-F-29**: System must send slash commands to backend without special processing (backend handles interpretation)

### Connection Handling

- **REQ-F-30**: System must send `select_vault` message on WebSocket connect
- **REQ-F-31**: System must re-send vault selection on WebSocket reconnect
- **REQ-F-32**: System must handle `SESSION_NOT_FOUND` errors by clearing stale session ID and starting fresh
- **REQ-F-33**: System must abort in-flight queries when starting new query or closing connection

### Inspiration Integration

- **REQ-F-34**: System must populate input with inspiration text when `discussionPrefill` is set
- **REQ-F-35**: System must clear `discussionPrefill` from context after populating input
- **REQ-F-36**: Inspiration prefill must NOT auto-submit (user must click send)

## Non-Functional Requirements

- **REQ-NF-1** (Performance): Message chunks must stream to UI within 100ms of receipt from WebSocket
- **REQ-NF-2** (Performance): Sessions must resume in under 500ms when metadata file exists
- **REQ-NF-3** (Usability): Auto-scroll to bottom must activate when new messages arrive
- **REQ-NF-4** (Usability): Send button must disable when input is empty or connection is lost
- **REQ-NF-5** (Usability): Messages must display HH:MM timestamps in 12/24-hour format based on locale
- **REQ-NF-6** (Accessibility): Conversation list must have `role="list"` and `aria-label="Conversation"`
- **REQ-NF-7** (Accessibility): Input must have `aria-label="Message input"`
- **REQ-NF-8** (Accessibility): Send button must have `aria-label="Send message"`
- **REQ-NF-9** (Accessibility): Tool cards must have `role="listitem"` and `role="button"` with keyboard support (Enter/Space)
- **REQ-NF-10** (Accessibility): Tool cards must set `aria-expanded` attribute correctly
- **REQ-NF-11** (Security): Session IDs must be validated with safe pattern `/^[a-zA-Z0-9_.-]+$/` (max 256 chars)
- **REQ-NF-12** (Security): Session file paths must reject `..`, `/`, and `\` characters
- **REQ-NF-13** (Reliability): System must interrupt active query before starting new query to prevent overlapping responses
- **REQ-NF-14** (Reliability): Session files must survive process restarts (persisted to disk)
- **REQ-NF-15** (Maintainability): WebSocket messages must validate against Zod schemas before processing
- **REQ-NF-16** (Maintainability): SDK errors must map to user-friendly messages (ENOENT → "executable not found", etc.)

## Explicit Constraints (DO NOT)

- Do NOT allow multiple concurrent queries per session (abort previous query first)
- Do NOT auto-submit inspiration prefill text (user must explicitly send)
- Do NOT modify session metadata while query is in progress (wait for completion)
- Do NOT store session files outside `~/.memory-loop/sessions/` directory
- Do NOT allow session IDs with path traversal characters (`../`, `/`, `\`)
- Do NOT send discussion messages before vault is selected
- Do NOT display raw SDK events to users (map to protocol messages first)
- Do NOT persist drafts to session metadata (localStorage only)
- Do NOT submit empty messages (trim and validate before sending)

## Technical Context

- **Existing Stack**:
  - Frontend: React 19, Vite, Bun test, TypeScript strict mode
  - Backend: Hono, Bun runtime, Claude Agent SDK
  - Shared: Zod for protocol validation
  - WebSocket: Native browser WebSocket API

- **Integration Points**:
  - Claude Agent SDK: `query()` function with options (cwd, allowedTools, permissionMode, maxTurns, maxBudgetUsd)
  - WebSocket protocol: Discriminated unions for type-safe message routing
  - SessionContext: React Context API for state management (vault, sessionId, messages)
  - LocalStorage: Draft persistence with key `memory-loop-discussion-draft`
  - Filesystem: Session persistence at `~/.memory-loop/sessions/{sessionId}.json`

- **Patterns to Respect**:
  - WebSocket messages validated with `safeParse()` and discriminated unions
  - Error handling with custom error classes (`SessionError`, `FileBrowserError`)
  - SDK event streaming with async generators
  - React hooks (`useWebSocket`, `useSession`, `useServerMessageHandler`)
  - Component composition (Discussion → MessageBubble, ToolDisplay)

## Acceptance Tests

### Message Submission

1. **Submit text message**: User types "Hello Claude" and clicks Send → Message appears in conversation, input clears, streaming response begins
2. **Submit with Enter key**: User types message and presses Enter → Message submits (same as clicking Send)
3. **Shift+Enter adds newline**: User types text and presses Shift+Enter → Newline added without submitting
4. **Empty message blocked**: User clicks Send with empty/whitespace-only input → Nothing happens, button remains disabled

### Session Lifecycle

5. **Create new session**: User sends first message in fresh Discussion mode → Backend creates session, returns session_ready with sessionId, response streams
6. **Resume session on reconnect**: User refreshes page with existing sessionId in localStorage → Backend sends session_ready with message history, conversation displays
7. **Clear session**: User clicks "New" button → Frontend sends new_session, backend clears sessionId, sends empty session_ready, conversation clears
8. **Session not found fallback**: User tries to resume deleted session → Backend sends SESSION_NOT_FOUND error, frontend clears sessionId, sends select_vault

### Streaming and Display

9. **Stream response chunks**: Backend sends response_start, multiple response_chunk, response_end → Frontend displays chunks incrementally with typing cursor, cursor disappears on response_end
10. **Markdown rendering**: Assistant message contains `**bold**` and `- list item` → Rendered with proper HTML formatting (bold text, bullet list)
11. **Auto-scroll on new message**: User scrolls up, new message arrives → View auto-scrolls to bottom smoothly

### Tool Usage

12. **Display tool invocation**: Backend sends tool_start (Read, file.md), tool_input ({file_path: "file.md"}), tool_end ("contents") → Tool card appears with "Read" title, collapsed shows "file.md", expanded shows input and output
13. **Tool loading state**: Backend sends tool_start but not tool_end yet → Tool card shows spinning loader
14. **Expand/collapse tool**: User clicks tool card → Card expands showing input/output, clicks again → Card collapses
15. **Tool keyboard access**: User tabs to tool card, presses Enter → Card expands/collapses

### Draft Persistence

16. **Save draft on input change**: User types "draft message" but doesn't send → Refreshes page → Input field contains "draft message"
17. **Clear draft after send**: User types message, clicks Send → LocalStorage draft cleared
18. **Prefill takes precedence**: LocalStorage has "old draft", inspiration sets prefill "new prompt" → Input shows "new prompt", prefill cleared from context

### Error Handling

19. **No vault selected error**: User sends message before selecting vault → Error message "No vault selected. Send select_vault first."
20. **SDK error mapping**: SDK throws ENOENT error → Frontend displays "Claude Code executable not found. Please ensure Claude Code is installed."
21. **Abort in-flight query**: User sends message A, immediately sends message B before A completes → Query A aborted, query B starts fresh

### Slash Commands

22. **Detect slash command**: User types "/help" → Hint "Slash command detected" appears above input
23. **Send slash command**: User sends "/search pattern" → Backend receives discussion_message with "/search pattern" text

## Open Questions

- [ ] Should session pruning happen on every session creation or scheduled background task?
- [ ] What is the maximum number of sessions to keep per vault? (Currently hardcoded to 5)
- [ ] Should failed SDK queries be retried automatically or require manual user retry?
- [ ] Should tool cards remain visible after conversation ends or be hidden?
- [ ] How should the system handle session resume when vault no longer exists?

## Out of Scope

- Voice input/output for messages
- Message editing or deletion (conversations are append-only)
- Multi-user collaborative conversations
- Message reactions or annotations
- Export conversation to PDF or other formats
- Search within conversation history
- Conversation branching or forking
- Rate limiting or usage quotas (handled by SDK)
- Custom system prompts (SDK manages prompts)
- File uploads or attachments in messages

---

**Next Phase**: Once approved, use `/spiral-grove:plan-generation` to create technical implementation plan.
